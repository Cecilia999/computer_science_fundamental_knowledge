# 运行时数据区 Runtime Data Area

## 1. 概述

内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JV 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。

![alt text](/image/运行时数据区.jpg)

1. 一个虚拟机是一个进程：Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁\*（**堆 heap、方法区 method area**）。
2. 线程：另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁（**虚拟机栈 jvm stack、本地方法栈 native method stack、程序计数器 program counter register**）。

   - 每个线程私有：程序计数器、本地方法栈、虚拟机栈。
   - 线程间共享：堆、方法区（更恰当的称为**堆外内存**：永久代或元空间 + 代码缓存）

### 1.1 jvm 优化 -- 垃圾回收

线程的部分没什么优化的空间，垃圾回收主要是在线程共享，即进程层面的 heap(占 95%) 和 method area(占 5%).

### 1.2 java.lang.Runtime 类

**一个进程对应一个 JVM 实例，一个 JVM 实例只有一个 Runtime 实例。即为运行时环境，对应我们这里的运行时数据区。**
![alt text](/image/java.lang.Runtime.jpg)

### 1.3 线程与 jvm

- 线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。
- 在 Hotspot VM 里，每个线程都与操作系统的本地线程直接映射。
- 当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。
- 操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。
- 当 JVM 中的最后一个非守护线程被销毁时，JVM 相应的也可以停止了

如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main（string[] args）的 main 线程以及所有这个 main 线程自己创建的线程。

这些主要的**后台系统线程（守护线程）**在 Hotspot VM 里主要是以下几个：

- 虚拟机线程： 这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。
- 周期任务线程： 这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。
- GC 线程： 这种线程对在 Jvm 里不同种类的垃圾收集行为提供了支持。
- 编译线程： 这种线程在运行时会将字节码编译成到本地代码。
- 信号调度线程： 这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。

## 2.jvm 运行时数据区结构

### 2.1 程序计数器

PC 寄存器用来**存储指向下一条字节码指令的地址**，也即将要执行的指令代码。**由执行引擎读取下一条指令**。

![alt text](/image/程序计数器.jpg)

- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储下一条的字节码指令地址：或者，如果是在执行 native 方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是唯一一个在 Java 虚拟机规范中没有规定任何 OutotMemoryerror 情况的区域
  **没有 GC 不会 OOM(Out of memory 溢出)**

#### 2.1.1 程序计数器的示例

```java
package RunningDateArea.PCRegister;

public class PCRegisterTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;

        String s = "abc";
        System.out.println(i);
        System.out.println(k);
    }
}

```

反解析 `javap -v PCRegisterTest.class`
![alt text](/image/程序计数器示例.jpg)

可以看到 Code 部分是写好程序翻译成的字节码的形式：
第一列是指令地址（偏移地址），第二列是操作指令，第三列是对应常量池的数据

PC 寄存器存的就是指令地址，执行引擎读取 PC 寄存器的值，执行相应的字节码指令，操作局部变量表，操作数栈，运算操作等，还要转化为机器指令，供 CPU 执行

#### 2.1.2 程序计数器的面试问题

1. 使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？（同一问题两种问法）  
   因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
   JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。

2. Pc 寄存器为什么会被设定为线程私有
   如果线程共享一个 PC 寄存器，就会发生覆盖，切换之后无法回到原本线程该执行的字节码指令  
   由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

### 2.2 虚拟机栈 - JVM Stack

Stack 栈 是**运行时的单位**，而 Heap 堆 是**存储的单位**。  
即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。（堆放对象，栈放基础类型的数据和对象的引用）

#### 2.2.1 JVM Stack 是什么

- 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈桢（**Stack frame**），一个 stack frame 栈桢对应一个 java 方法的调用，栈桢是 stack 里存储数据的基本单位
- 是线程私有的。
- 生命周期：生命周期和线程一致
- 作用：主管 Java 程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

#### 2.2.2 JVM Stack 的特点

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
- JVM 直接对 Java 栈的操作只有两个：
  1. 每个方法执行，伴随着进栈（入栈、压栈）
  2. 执行维束后的出栈工作
- 对于栈来说不存在垃圾回收问题（GC），但存在内存溢出（OOM）
  ![alt text](/image/出栈入栈.jpg)

#### 2.2.3 JVM Stack 溢出问题

Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的，但无论哪种都可能会出现错误（JVM 的错误 Error）

- 如果采用**固定大小的 Java 虚拟机栈**，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个**StackOverflowError**异常。
- 如果**Java 虚拟机栈可以动态扩展**，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 **OutofMemoryError**异常。

示例

```java
public class StackOverflowErrorTest {
    /**
     * 演示StackOverflowError，主要由于递归深度过深，栈桢太多超出虚拟机栈内存大小引起的
     * @param args
     */
    private static int count = 1;
    public static void main(String[] args) {
        System.out.println(count);
        count++;
        main(args);
    }
}

```

![alt text](/image/栈的stackoverflow.jpg)
